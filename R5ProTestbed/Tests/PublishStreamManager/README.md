# Stream Manager Publishing with Transcoder

With clustering, we need to determine which Red5 Pro instance the client will use. The other examples used a static configuration IP for streaming endpoints. Basic clustering uses more than one stream endpoint for subscribers. Advanced clustering uses more than one endpoint for publishers also.

With the Stream Manager, our configuration IP will be used similarly for publishers and subscribers. Both publishers and subscribers will call a web service to receive the IP that should be used. Since this is an HTTP call, you can use a DNS Name for the `host` value. 
## Transcoder Support

To enable Adaptive Bitrate (ABR) control of a stream being played back by a consumer, you need to POST a provision to the Stream Manager detailing the variants at which you will be broadcasting.

For scenarios in which the broadcaster does not have the capability of publishing the variants of the provision, the broadcaster can request that the server does the Transcoding to the variants.

To do so - once the provision has been provided to the Stream Manager - the broadcast must be streamed to the root GUID defined on the provision. The Transcoder will that generate the additional variants for consumption.

### Example Code

- ***[BaseTest.swift](../BaseTest.swift)***
- ***[PublishStreamManagerTest.swift](PublishStreamManagerTest.swift)***

# Setup

## Provision

In order to publish using the transcoder, you first need to provide the Stream Manager with a provision manifest detailing the variants desired to be generated by the transcoder. This is a simple POST request that can be done outside of the actual publishing client - such as using `cURL` - but for the purposes of this example, the provision is posted prior to the broadcast. Additionally, the POST of the provision is an authenticated request and requires an authorization token first access from the Stream Manager.

The following is an example of the schema for the provision to be posted:

```json
[
  {
    "streamGuid": "live/test",
    "streams": [
      {
        "streamGuid": "live/test_3",
        "abrLevel": 3,
        "videoParams": {
          "videoWidth": 320,
          "videoHeight": 180,
          "videoBitRate": 500000
        }
      },
      {
        "streamGuid": "live/test_2",
        "abrLevel": 2,
        "videoParams": {
          "videoWidth": 640,
          "videoHeight": 360,
          "videoBitRate": 1000000
        }
      },
      {
        "streamGuid": "live/test_1",
        "abrLevel": 1,
        "videoParams": {
          "videoWidth": 1280,
          "videoHeight": 720,
          "videoBitRate": 2000000
        }
      }
    ]
  }
]
```

### Authorization

To request an authorization token:

```Swift
let data = "\(username):\(password)".data(using: .utf8)!
let base64String = data.base64EncodedString()
let url = "https://\(host)/as/v1/auth/login"
var request = URLRequest(url: URL(string: url)!)
request.httpMethod = "PUT"
request.setValue("Basic \(base64String)", forHTTPHeaderField: "Authorization")

let session = URLSession.shared
let task = session.dataTask(with: request) { data, response, error in
        // Handle response
    if let error = error {
        print("Error: \(error)")
        resolve(nil, error)
        return
    }

    if let httpResponse = response as? HTTPURLResponse {
        print("Status code: \(httpResponse.statusCode)")
        if let data = data {
            // Handle data
            print("Response data: \(String(data: data, encoding: .utf8) ?? "")")
            if (httpResponse.statusCode >= 200 && httpResponse.statusCode < 300) {
                var json: [String: AnyObject]
                do {
                    json = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions()) as! [String: AnyObject]
                    if let errorMessage = json["errorMessage"] as? String {
                        resolve(nil, AccessError.error(message: errorMessage))
                    } else if let token = json["token"] as? String {
                        resolve(token, nil)
                    }
                } catch {
                    print(error)
                    return
                }
            }
        }
    } else {
        resolve(nil, AccessError.error(message: "Could not complete request"))
    }
}
```

### Provision POST

Once an authorization token has been received, the provision listing the stream variants can be POSTed:

```Swift
let host = (Testbed.getParameter(param: "host") as! String)
let version = (Testbed.getParameter(param: "sm_version") as! String)
let nodeGroup = (Testbed.getParameter(param: "sm_nodegroup") as! String)
let url = "https://\(host)/as/\(version)/streams/provision/\(nodeGroup)"

let jsonData = try? JSONSerialization.data(withJSONObject: [provisionData])
var request = URLRequest(url: URL(string: url)!)
request.httpMethod = "POST"
request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
request.setValue("\(jsonData!.count)", forHTTPHeaderField: "Content-Length")
request.setValue("application/json", forHTTPHeaderField: "Content-Type")
request.httpBody = jsonData
```

## Transcoder Node

In order to publish using the transcoder, you need to request to endpoint for the transcoder from the Stream Manager just as you would in accessing the Origin endpoint in a normal Stream Manager request for broadcast and you will need to do so using the `streamGuid` from the root of the submitted provision - for the purposes of this example, that is `live/test`.

```Swift
let host = (Testbed.getParameter(param: "host") as! String)
let port = (Testbed.getParameter(param: "server_port") as! String)
let portURI = port == "80" ? "" : ":" + port
let version = (Testbed.getParameter(param: "sm_version") as! String)
let nodeGroup = (Testbed.getParameter(param: "sm_nodegroup") as! String)

let originURI = "\(host)\(portURI)/as/\(version)/streams/stream/\(nodeGroup)/publish/\(streamGuid)?transcode=true"

...

var json: [[String: AnyObject]]
do {
    json = try JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions()) as! [[String: AnyObject]]
} catch {
    print(error)
    return
}

if let origin = json.first {
    if let ip = origin["serverAddress"] as? String,
       let guid = origin["streamGuid"] as? String {
        NSLog("Retrieved %@ from %@, of which the usable IP is %@", dataAsString!, url, ip);
        resolve(ip, guid, error)
    }
    else if let errorMessage = origin["errorMessage"] as? String {
        resolve(nil, nil, AccessError.error(message: errorMessage))
    }
}
```

With the Transcoder node to broadcast to, you will most likely begin your broadcast with the settings from the highest variant of the provision - seeing as the transcoder only down-samples to the variants defined.

## Broadcast Stream Name

Providing the top-level stream variant from the provision, you will then request to broadcast with the `streamGuid` defined within; for the purposes of this example, that would be `live/test_1`:

```Swift
var paths = guid!.split(separator: "/")
let streamName = String((paths.popLast())!)
let scope = paths.joined(separator: "/")

//   Setup a configuration object for our connection
let config = R5Configuration()
config.host = ip
config.port = Int32(Testbed.getParameter(param: "port") as! Int)
config.contextName = scope
config.`protocol` = 1;
config.buffer_time = Testbed.getParameter(param: "buffer_time") as! Float
config.licenseKey = Testbed.getParameter(param: "license_key") as! String
// Tell it to transcode!
config.parameters = "transcode=true;"
```

After successfully starting a broadcast usign the top-level `streamGuid` as the `context` and `streamName`, that stream and the other variant streams will be available to subscribe to.

> It should be noted that when starting a subscriber to a stream variant, the server will determine which variant level to deliver to the subscriber client based on bandwidth estimation on the subscriber side.
